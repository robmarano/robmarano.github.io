# Assignment 4

<5 points>

### Homework Pointing Scheme

| Total points | Explanation |
| -----------: | :---------- |
|            0 | Not handed in |
|            1 | Handed in late |
|            2 | Handed in on time, not every problem fully worked through and clearly identifying the solution |
|            3 | Handed in on time, each problem answered a boxed answer, each problems answered with a clearly worked through solution, and **less than majority** of problems answered correctly |
|            4 | Handed in on time, **majority** of problems answered correctly, each solution boxed clearly, and each problem fully worked through |
|            5 | Handed in on time, every problem answered correctly, every solution boxed clearly, and every problem fully worked through. |

## Reading

*   **Notes**: [Week 4 Notes](/courses/ece251/2026/weeks/week_04/notes_week_04.html)
*   **Textbook**: Chapter 2 (ISA) and SystemVerilog Reference (if available)

## Problem Set

### Part 1: MIPS ISA Review

**1. Machine Code Translation (R-Type and I-Type)**

Translate the following MIPS assembly instructions into **32-bit binary** and **8-digit hexadecimal**. Refer to the MIPS Reference Data Card (Green Card) for opcodes and function codes.

a) `add $t0, $s1, $s2` (Registers: $t0=8, $s1=17, $s2=18)
b) `lw  $t0, 32($s3)` (Registers: $t0=8, $s3=19, Opcode for lw=35)

*   **Goal**: Understand instruction formats (R-Type vs I-Type) and field bit-widths.

**2. Memory Addressing & Endianness**

Assume we have a 32-bit integer `0x12345678` stored at memory address `0x10000000`.

a) If the machine is **Big Endian** (like MIPS often is), what byte value is stored at address `0x10000000`?
b) If the machine is **Little Endian** (like x86), what byte value is stored at `0x10000000`?
c) Explain the difference between **PC-Relative Addressing** (used in `beq`) and **Base Addressing** (used in `lw`). Which one relies on a register for the base address?

*   **Goal**: Solidify understanding of memory byte ordering and addressing modes required for CPU control logic.

**3. Procedure Call Stack Frames**

You are writing a procedure `foo` that calls another procedure `bar`.
`foo` uses registers `$s0`, `$s1`, and `$t0`.

a) Which of these registers (`$s0`, `$s1`, `$t0`, `$ra`) **must** be saved to the stack by `foo` before calling `bar`? Explain why for each.
b) Write the **MIPS assembly code** for the "Prologue" of `foo` (saving necessary registers and decrementing the stack pointer). Assume `$sp` needs to stay 4-byte aligned.

*   **Goal**: Master stack manipulation, a critical concept for implementing `jal` and `jr` in your CPU.

---

### Part 2: SystemVerilog Fundamentals

**4. Building a Datapath Component: The Multiplexor**

Multiplexors are the "traffic cops" of a CPU, directing data to the ALU or Register File.

a) Write a SystemVerilog module for a **2-to-1 Multiplexor** (`mux2`) using **Dataflow modeling** (the ternary `? :` operator). It should switch 32-bit wide busses.
b) Using your `mux2` module from part (a), create a **Structural** module for a **4-to-1 Multiplexor** (`mux4`). (Hint: You will need three instances of `mux2`).

*   **Goal**: Practice hierarchical design and bus logic.

**5. Building a State Element: The Program Counter (PC)**

The Program Counter is simply a register that holds the current instruction address.

Write a SystemVerilog module `register_n` with the following specifications:
*   **Parameters**: `WIDTH` (default to 32).
*   **Inputs**: `clk`, `rst_n` (active-low asynchronous reset), `en` (write enable), `d` (input data).
*   **Outputs**: `q` (output data).
*   **Behavior**:
    *   On `rst_n` going low (0), `q` resets to 0.
    *   On rising edge of `clk`: if `en` is high, capture `d` into `q`. Otherwise, keep `q` unchanged.

*   **Goal**: Create the fundamental state-holding element used for the PC, Register File, and Pipeline registers.

---

## Submission

Submit your answers as a PDF or Markdown file. For the coding problems (4 & 5), you may paste your SystemVerilog code directly into the document.
