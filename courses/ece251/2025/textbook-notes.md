# Course Notes
[<- back to syllabus](/courses/ece251/2025/ece251-syllabus-spring-2025.md)
## Prologue

"What I hear, I forget; What I see I remember; What I do, I understand." &mdash; Confucius (551-479 B.C.)

It is commonly understood that enlighted people of the twenty-first century come to understand the key principles underlying bits, atoms, neurons, and genes. Science has been rather remarkable to uncover the basic operating systems for each of these principles. Unlike the last three principles, enlightened practitioners can fully understand every facet of how bits and their operating systems, as described by electrical engineering and computer science, work together to enable computers to help power our modern age. This course, "ECE 251 &mdash; Computer Architeture," focuses on the hardware designs that enable us to write and execute increasingly complex applications, leading us to create artifical general intelligence (AGI) over the course of the next decade or two, or sooner. Computers have become the most important machines (automata) in the twenty-first century.

In the early days of computers and their design and implementation, to fully understand the full monty from hardware to softare had been available to anyone who desired. The interactions between hardware and software were simple and transparent enough to produce a coherent picture of the full operation of the computer from transistors on up to the program executed. However, over the last half century digital technologies (science and engineering) have become increasingly complex. The fundamental ideas and techniques across hardware and software systems are not sufficiently hidden behind layers of complexities wrapped in abstractions and packaged in interfaces and proprietary implementations. Specialization became the inevitable consequence of this complex abstractions. As students of electrical engineering and/or computer science, you pursue studies of courses each of which focus on a single aspect of the field of computing. ECE 251 works to provide you, the student, to see the forest for the trees, as the age-old saying goes, that is, to focus on the full operation of a computer, rather than getting caught up in details of the hardware or software engineering. We show you how computers work from fundamental principles you have learned in digital logic design and introductory computer science's "Hello, World" programming.

This course paints the bigger picture of hardware, software, and application systems as tightly interrelated through integrated abstractions, interfaces, and contract-based implementations. Educators of this art, science, and engineering practice know that the best way to understand how computers work is to build one from scratch, yourself. We will specify a simple but powerful computer system, and you will build its respective hardware and software hierarchies from the ground up. You may just come to feel the thrill of constructing fantasically complex and useful systems from first principles, through careful reasoning and modular design and implementation.

You will work to create the outcome of fully functioning computer, i.e., five parts that are the CPU, memory, data path, input, and output. We start with logic gates and end up with a computer that can be programmed to output calculations, even play a game, e.g., Conway's Game of Life, Tetris, and Pong. You will design, build, redesign, rebuild in a series of steps all the components inside the computer's five main parts. Richard Feynman once said, "What I cannot create, I do not understand." This course will be all about understanding through the trials of creation. Many people, especially students of engineering and computer science, connect to this "maker mentality."

Let's create!

## Course Scope

Our ECE 251 course exposes to each student a significant body of computer engineering and computer science knowledge gained through a series of hardware and software construction tasks; for example, hardware, architecture, and low-level computer language. **Hardware** includes a review of combinational and sequential logic design using the Verilog hardware description language (HDL); for example, logic gates, multiplexers, flip-flops. registers, RAM units, and counters (state machines should time allow) along with simulation, verification, and testing. **Architecture** includes the design and implementation of arithmetic logic unit (ALU), control units, central processing unit (CPU), addressing modes, fetch and execute logic, instruction set, and memory-mapped input and output. Finally, **low-level languages** include design and implementation of simple machine language (binary and symbolic), instruction set, and assembly language programming.

## Course Structure

The course is based upon the "abstraction-implementation paradigm." Each topic module starts with its **Introduction** section that introduces and describes the relevant concepts along with a generic hardware or software system. The next section, called **Specification**, describes the system's abstraction of functionality, i.e., the various services that the module is expected to deliver. The introduction and specification state the "what" of the topic module. Proceeding from what the topic does, the next section, called **Implementation**, discusses "how" this abstraction can be realized. Almost always there are many ways to implement, but the performance requirements will dictate which implementation technique to use. It is both a science and an art that comes with experience. This course focuses on functionality, not necessarily performance other than your implementations must work. :smile:

The course (**hardware**) starts with a review of boolean logic, algebra using the HDL called "Verilog," which will serve as the implementation of our digital logic "chips" to realize combinational logic circuits and sequential logic circuits combined together using abstraction to result in compute, storage ("memory") and control of a computer design. Once the compute and memory circuits have been created in Verilog, we will discuss low-level programming, specificying a machine language in both its symbolic and binary forms. We will focus on the use of four design principles that drive modern computer architecture design.
